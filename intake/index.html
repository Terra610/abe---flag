<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Intake — Document + OCR Bridge | A.B.E.</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <base href="/abe---flag/">
  <link rel="stylesheet" href="abe-patch/assets/abe-patch.css"/>

  <style>
    .intake-wrap{max-width:1100px;margin:0 auto;padding:1.4rem 1rem 3rem}
    .intake-grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(260px,1fr))}
    .mono{font-family:ui-monospace,SFMono-Regular,Consolas,monospace;font-size:.85rem}
    .dropzone{
      border:1px dashed var(--line);
      border-radius:12px;
      padding:18px 16px;
      text-align:center;
      cursor:pointer;
      background:var(--panel2);
    }
    .dropzone.dragover{
      border-style:solid;
      background:rgba(93,223,255,.08);
    }
    .small{font-size:.9rem;color:var(--muted)}
    textarea.intake-text{
      width:100%;
      min-height:160px;
      border-radius:10px;
      border:1px solid var(--line);
      background:#0f131a;
      color:var(--ink);
      padding:.6rem .7rem;
      resize:vertical;
    }
    .pill-row{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
    .pill{
      border-radius:999px;
      border:1px solid var(--line);
      padding:3px 9px;
      font-size:.85rem;
      cursor:pointer;
      background:var(--panel2);
    }
    .pill.active{
      border-color:var(--brand);
      box-shadow:0 0 0 1px rgba(93,223,255,.4);
    }
    .btn-row{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px}
    pre.preview{
      background:#0f131a;
      border-radius:10px;
      border:1px solid var(--line);
      padding:.6rem .7rem;
      max-height:220px;
      overflow:auto;
      white-space:pre-wrap;
    }
  </style>

  <!-- OCR library (runs entirely in the browser; documents never leave the device) -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body class="abe-page">

<header class="abe-header">
  <div class="intake-wrap">
    <a href="/abe---flag/index.html" class="chip">← Home</a>
    <h1>Intake — Document + OCR Bridge</h1>
    <p class="tagline">
      Upload one document (ticket, CPS letter, loan contract, memo), read it locally with OCR,
      and export A.B.E.-ready files for CIRI, CDA, CFF, and CCRI — without leaving your browser.
    </p>
    <nav class="chip-row">
      <span class="chip">Intake · alpha · local only</span>
      <a class="chip" href="ciri/index.html">CIRI</a>
      <a class="chip" href="cda/index.html">CDA</a>
      <a class="chip" href="cff/index.html">CFF</a>
      <a class="chip" href="ccri/index.html">CCRI</a>
      <a class="chip chip-alt" href="system/index.html">System Map</a>
    </nav>
  </div>
</header>

<main class="abe-main intake-wrap">

  <!-- 1. Upload + doc type -->
  <section class="card">
    <h2>1. Add your document</h2>
    <p class="small">
      Intake runs completely in your browser. Your file is never uploaded to a server.
      Images (photos / scans) will use OCR. Text files are read directly.
    </p>

    <div id="dropzone" class="dropzone">
      <strong id="file-label">Click to choose a file, or drop it here</strong>
      <div class="small" style="margin-top:4px">
        Suggested: clear photo/scan (PNG/JPG) or plain-text file. PDFs may require exporting to images first.
      </div>
      <input id="file-input" type="file" style="display:none"
             accept="image/*,.txt,.text,application/pdf"/>
    </div>

    <div style="margin-top:12px;display:flex;flex-wrap:wrap;gap:12px;align-items:center">
      <label class="small">
        Document type:
        <select id="doc-type" style="margin-left:4px">
          <option value="traffic_ticket">Traffic / citation ticket</option>
          <option value="cps_case">CPS / child welfare file</option>
          <option value="policy_memo">Policy / memo</option>
          <option value="loan_contract">Loan or credit contract</option>
          <option value="generic_case_text">Plain text description</option>
        </select>
      </label>
      <span id="hash-display" class="small mono">SHA-256: —</span>
    </div>
  </section>

  <!-- 2. Text + basic fields -->
  <section class="card">
    <h2>2. Check the text</h2>
    <p class="small">
      Intake will try to read everything for you. You can edit this text freely — the engine
      will only use what you see here.
    </p>
    <textarea id="text-normalized" class="intake-text mono"
              placeholder="When you add a file, the text will appear here. You can also paste or type directly."></textarea>
    <div class="small" style="margin-top:4px">
      OCR status: <span id="ocr-status">waiting for file…</span>
    </div>
  </section>

  <!-- 3. Choose target modules -->
  <section class="card">
    <h2>3. Where should this go?</h2>
    <p class="small">
      Choose which parts of the A.B.E. engine this intake session should feed.
      You can download all generated files and upload them into each module’s page.
    </p>
    <div class="pill-row" id="targets">
      <button type="button" class="pill active" data-target="CIRI">CIRI · economic harm / recovery</button>
      <button type="button" class="pill" data-target="CDA">CDA · divergence scenario</button>
      <button type="button" class="pill" data-target="CFF">CFF · funding forensics</button>
      <button type="button" class="pill" data-target="CCRI">CCRI · credit risk integrity</button>
    </div>

    <div class="btn-row">
      <button id="btn-build" class="btn">Build Intake Artifact</button>
      <button id="btn-download-intake" class="btn" disabled>Download intake_artifact.json</button>
      <button id="btn-download-ciri" class="btn" disabled>Download CIRI inputs.csv</button>
      <button id="btn-download-ccri" class="btn" disabled>Download CCRI scenario.json</button>
    </div>
  </section>

  <!-- 4. Preview outputs -->
  <section class="card">
    <h2>4. Preview generated data</h2>
    <div class="intake-grid">
      <div>
        <h3>CIRI CSV preview</h3>
        <pre id="preview-ciri" class="preview mono">—</pre>
        <p class="small">
          This is a one-row <code>inputs.csv</code> you can upload on the CIRI page.
          You will probably edit the numbers there — this is just a scaffold.
        </p>
      </div>
      <div>
        <h3>Intake artifact JSON (summary)</h3>
        <pre id="preview-intake" class="preview mono">—</pre>
        <p class="small">
          This file records the hash of your original document, normalized text,
          chosen targets, and hashes of any generated outputs.
        </p>
      </div>
    </div>
  </section>

</main>

<footer class="abe-footer">
  <p>
    CC BY-NC 4.0 · Intake module · Integrity only — never for sale.
  </p>
</footer>

<script>
(function(){
  const dropzone   = document.getElementById('dropzone');
  const fileInput  = document.getElementById('file-input');
  const fileLabel  = document.getElementById('file-label');
  const hashDisplay= document.getElementById('hash-display');
  const textArea   = document.getElementById('text-normalized');
  const ocrStatus  = document.getElementById('ocr-status');
  const docTypeSel = document.getElementById('doc-type');
  const targetRow  = document.getElementById('targets');
  const btnBuild   = document.getElementById('btn-build');
  const btnIntake  = document.getElementById('btn-download-intake');
  const btnCiri    = document.getElementById('btn-download-ciri');
  const btnCcri    = document.getElementById('btn-download-ccri');
  const prevCiri   = document.getElementById('preview-ciri');
  const prevIntake = document.getElementById('preview-intake');

  let currentFile = null;
  let currentHash = null;
  let lastArtifact = null;
  let lastCiriCsv = null;
  let lastCcriScenario = null;

  // --- helpers ----------------------------------------------------
  async function sha256Hex(arrayBuffer){
    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
    const bytes = new Uint8Array(hashBuffer);
    return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
  }

  function getSelectedTargets(){
    return Array.from(targetRow.querySelectorAll('.pill'))
      .filter(p=>p.classList.contains('active'))
      .map(p=>p.dataset.target);
  }

  function toggleTarget(e){
    const pill = e.target.closest('.pill');
    if(!pill) return;
    pill.classList.toggle('active');
  }

  targetRow.addEventListener('click', toggleTarget);

  // --- file handling + OCR ----------------------------------------
  function handleFile(file){
    currentFile = file;
    currentHash = null;
    fileLabel.textContent = file.name;
    ocrStatus.textContent = 'computing hash…';
    hashDisplay.textContent = 'SHA-256: …';

    const reader = new FileReader();
    reader.onload = async (ev)=>{
      const buf = ev.target.result;
      try{
        currentHash = await sha256Hex(buf);
        hashDisplay.textContent = 'SHA-256: ' + currentHash;
      }catch(_){
        hashDisplay.textContent = 'SHA-256: (could not compute)';
      }

      if(file.type && file.type.startsWith('image/')){
        // OCR path
        ocrStatus.textContent = 'running OCR in your browser…';
        try{
          const { data:{ text } } = await Tesseract.recognize(
            file,
            'eng',
            { logger:()=>{} }
          );
          textArea.value = text.trim();
          ocrStatus.textContent = 'OCR complete — review and edit as needed.';
        }catch(err){
          ocrStatus.textContent = 'OCR failed: ' + err.message;
        }
      }else{
        // treat as text-ish
        try{
          const asText = new TextDecoder().decode(buf);
          textArea.value = asText.trim();
          ocrStatus.textContent = 'Loaded as text — review and edit as needed.';
        }catch(err){
          ocrStatus.textContent = 'Could not read as text: ' + err.message;
        }
      }
    };
    reader.readAsArrayBuffer(file);
  }

  dropzone.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(f) handleFile(f);
  });

  function dzPrevent(e){e.preventDefault();e.stopPropagation();}
  ['dragenter','dragover','dragleave','drop'].forEach(ev=>{
    dropzone.addEventListener(ev, dzPrevent);
  });
  dropzone.addEventListener('dragover', ()=> dropzone.classList.add('dragover'));
  dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('dragover'));
  dropzone.addEventListener('drop', (e)=>{
    dropzone.classList.remove('dragover');
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if(f) handleFile(f);
  });

  // --- output builders --------------------------------------------

  function buildCiriCsv(){
    // Skeleton row; values are placeholders the user will edit in CIRI.
    const header = [
      'cases_avoided',
      'avg_cost_per_case',
      'jail_days_avoided',
      'cost_per_jail_day',
      'fees_canceled_total',
      'policy_corrections',
      'avg_enforcement_cost_savings',
      'households_restored',
      'avg_monthly_market_spend',
      'months_effective',
      'employment_probability',
      'avg_monthly_wage',
      'expected_lawsuits',
      'avg_payout',
      'litigation_multiplier',
      'transition_costs_one_time'
    ];

    const row = [
      1,      // cases_avoided
      5000,   // avg_cost_per_case
      0,
      120,
      0,
      0,
      0,
      1,
      400,
      12,
      0.3,
      2500,
      0,
      0,
      1.0,
      0
    ];

    return header.join(',') + '\n' + row.join(',');
  }

  function buildCcriScenario(text){
    return {
      version: "1.0",
      module: "CCRI",
      scenarios: [
        {
          id: "intake_example_1",
          jurisdiction: "",
          institution_type: "auto_finance",
          institution_name: "",
          loan_types: ["auto_purchase"],
          uses_ssn_for: [],
          data_sources_used: {
            credit_bureau: true,
            paystubs_or_w2: false,
            bank_statements: false,
            dmv_records: true,
            dot_or_fmcsa_records: false,
            third_party_background_vendors: false,
            other_public_records: false
          },
          dmv_usage_details: {
            pulled_for_identity_only: true,
            used_in_underwriting_decisions: false,
            used_for_pricing_or_interest_rate: false,
            fields_used: [],
            notes: "Generated from Intake; edit to reflect actual practice."
          },
          dot_or_fmcsa_usage_details: {
            is_dot_regulated_population: false,
            pulls_cdl_or_safety_record: false,
            uses_mcsap_or_fmcsr_flags: false,
            notes: ""
          },
          license_requirements: {
            requires_valid_license_to_apply: false,
            requires_valid_license_to_fund_loan: false,
            requires_valid_license_to_test_drive: false,
            exceptions_available: true,
            notes: ""
          },
          population_impact: {
            applications_per_year: 0,
            denial_rate_overall: 0,
            denial_rate_for_suspended_or_no_license: 0,
            estimated_noncommercial_applicants_affected: 0
          },
          denial_reasons_top: [],
          appeal_process: {
            has_appeal_mechanism: false,
            human_review_available: false,
            notes: ""
          },
          notes: "Free-form notes from Intake:\n" + text.slice(0, 1000)
        }
      ]
    };
  }

  // --- build artifact + wire downloads ----------------------------
  btnBuild.addEventListener('click', async ()=>{
    const text = textArea.value.trim();
    const docType = docTypeSel.value;
    const targets = getSelectedTargets();

    if(!text){
      alert('Please add a document and/or text first.');
      return;
    }

    const createdAt = new Date().toISOString();

    // Build optional outputs
    lastCiriCsv = null;
    lastCcriScenario = null;

    let ciriMeta = { present:false };
    let cdaMeta  = { present:false };
    let cffMeta  = { present:false };
    let ccriMeta = { present:false };

    if(targets.includes('CIRI')){
      lastCiriCsv = buildCiriCsv();
      ciriMeta = {
        present:true,
        row_count:1,
        csv_inline:lastCiriCsv,
        hash:null
      };
    }

    if(targets.includes('CCRI')){
      lastCcriScenario = buildCcriScenario(text);
      ccriMeta = {
        present:true,
        scenario:lastCcriScenario,
        hash:null
      };
    }

    // Build intake artifact (without hashes for generated outputs yet)
    lastArtifact = {
      version: "1.0",
      module: "Intake",
      doc_type: docType,
      original_file_name: currentFile ? currentFile.name : "(none-provided)",
      original_file_hash: currentHash || "",
      ocr_used: !!(currentFile && currentFile.type && currentFile.type.startsWith('image/')),
      text_raw: null,
      text_normalized: text,
      extracted_fields: {},
      targets: targets,
      generated_outputs: {
        ciri: ciriMeta,
        cda: cdaMeta,
        cff: cffMeta,
        ccri: ccriMeta
      },
      created_at: createdAt,
      notes: ""
    };

    // Compute hashes for generated outputs (if any)
    if(lastCiriCsv){
      const buf = new TextEncoder().encode(lastCiriCsv);
      ciriMeta.hash = await sha256Hex(buf);
    }
    if(lastCcriScenario){
      const buf = new TextEncoder().encode(JSON.stringify(lastCcriScenario));
      ccriMeta.hash = await sha256Hex(buf);
    }

    // Update previews
    prevCiri.textContent = lastCiriCsv || 'No CIRI CSV generated (target not selected).';
    prevIntake.textContent = JSON.stringify(lastArtifact,null,2);

    // Enable download buttons
    btnIntake.disabled = false;
    btnCiri.disabled   = !lastCiriCsv;
    btnCcri.disabled   = !lastCcriScenario;
  });

  function downloadBlob(filename, text){
    const blob = new Blob([text], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  btnIntake.addEventListener('click', ()=>{
    if(!lastArtifact) return;
    downloadBlob('intake_artifact.json', JSON.stringify(lastArtifact,null,2));
  });

  btnCiri.addEventListener('click', ()=>{
    if(!lastCiriCsv) return;
    downloadBlob('inputs.csv', lastCiriCsv);
  });

  btnCcri.addEventListener('click', ()=>{
    if(!lastCcriScenario) return;
    downloadBlob('ccri_scenario_from_intake.json', JSON.stringify(lastCcriScenario,null,2));
  });

})();
</script>

</body>
</html>
